# Interpreter for Cascade language
# Executes the AST generated by the parser, with robust error handling.

class CascadeRuntimeError(Exception):
    """Raised for runtime errors in Cascade programs."""
    pass

class Env:
    """Environment for variable/function/type bindings, supports nested scopes."""
    def __init__(self, parent=None):
        self.vars = {}
        self.parent = parent

    def set(self, name, value):
        """Set variable to value in current scope."""
        self.vars[name] = value

    def get(self, name):
        """Get variable value from current or parent scope."""
        if name in self.vars:
            return self.vars[name]
        elif self.parent:
            return self.parent.get(name)
        else:
            raise CascadeRuntimeError(f"Variable '{name}' not found")

def eval_expr(expr, env, functions):
    """Evaluate an expression node."""
    t = expr['type']
    if t == 'NumberLiteral':
        return expr['value']
    if t == 'StringLiteral':
        return expr['value']
    if t == 'BooleanLiteral':
        return expr['value']
    if t == 'ListLiteral':
        return [eval_expr(el, env, functions) for el in expr['elements']]
    if t == 'MapLiteral':
        return {pair['key']: eval_expr(pair['value'], env, functions) for pair in expr['pairs']}
    if t == 'Identifier':
        return env.get(expr['value'])
    if t == 'FunctionCall':
        f = functions[expr['name']]
        args = [eval_expr(arg, env, functions) for arg in expr.get('args',[])]
        return f(*args)
    if t == 'BinaryExpr':
        l = eval_expr(expr['left'], env, functions)
        r = eval_expr(expr['right'], env, functions)
        op = expr['operator']
        if op == '+': return l + r
        if op == '-': return l - r
        if op == '*': return l * r
        if op == '/': return l / r
        if op == '==': return l == r
        if op == '!=': return l != r
        if op == '<': return l < r
        if op == '<=': return l <= r
        if op == '>': return l > r
        if op == '>=': return l >= r
        if op == '&&': return l and r
        if op == '||': return l or r
        raise CascadeRuntimeError(f"Unknown operator {op}")
    raise CascadeRuntimeError(f"Unknown expression type: {t}")

class ReturnSignal(Exception):
    """Special exception for returning from a function."""
    def __init__(self, value):
        self.value = value

def exec_stmt(stmt, env, functions, types):
    """Execute a statement node."""
    t = stmt['type']
    if t == 'VariableDeclaration':
        val = eval_expr(stmt['value'], env, functions)
        env.set(stmt['name'], val)
    elif t == 'Assignment':
        val = eval_expr(stmt['value'], env, functions)
        env.set(stmt['name'], val)
    elif t == 'ConstantDeclaration':
        val = eval_expr(stmt['value'], env, functions)
        env.set(stmt['name'], val)
    elif t == 'FunctionDeclaration':
        def user_fn(*args):
            local_env = Env(env)
            for ix, param in enumerate(stmt['params']):
                local_env.set(param['name'], args[ix])
            try:
                for s in stmt['body']:
                    exec_stmt(s, local_env, functions, types)
            except ReturnSignal as ret:
                return ret.value
        functions[stmt['name']] = user_fn
    elif t == 'TypeDeclaration':
        types[stmt['name']] = {f['name']:f['type'] for f in stmt['fields']}
    elif t == 'IfStatement':
        for when in stmt['whens']:
            cond = eval_expr(when['condition'], env, functions)
            if cond:
                for s in when['body']:
                    exec_stmt(s, env, functions, types)
                return
        if stmt['otherwise']:
            for s in stmt['otherwise']['body']:
                exec_stmt(s, env, functions, types)
    elif t == 'CycleStatement':
        coll = eval_expr(stmt['collection'], env, functions)
        for el in coll:
            local_env = Env(env)
            local_env.set(stmt['element'], el)
            for s in stmt['body']:
                exec_stmt(s, local_env, functions, types)
    elif t == 'TryCatchStatement':
        try:
            for s in stmt['tryBlock']:
                exec_stmt(s, env, functions, types)
        except CascadeRuntimeError as e:
            catch_env = Env(env)
            catch_env.set(stmt['errVar'], str(e))
            for s in stmt['catchBlock']:
                exec_stmt(s, catch_env, functions, types)
    elif t == 'ThrowStatement':
        val = eval_expr(stmt['value'], env, functions)
        raise CascadeRuntimeError(str(val))
    elif t == 'ReturnStatement':
        val = eval_expr(stmt['value'], env, functions)
        raise ReturnSignal(val)
    elif t == 'ExpressionStatement':
        eval_expr(stmt['expression'], env, functions)
    elif t == 'ImportStatement':
        # Imports are no-ops in the interpreter but could load modules in the future.
        pass
    else:
        raise CascadeRuntimeError(f"Unknown statement type: {t}")

def run_program(ast):
    """Run a Cascade program AST. Returns the final environment, functions, and types."""
    env = Env()
    functions = {}
    types = {}
    for stmt in ast['body']:
        exec_stmt(stmt, env, functions, types)
    return env, functions, types